function dev_generate_polynomial_code(fname, genname, Kfun, betafun, opt)
% dev_generate_polynomial_code(fname, genname, Kfun, betafun, opt)
%
% Function used by `dev_generate_basic_kaiser_poly.m` and
% `dev_generate_basic_kaiser_poly_deriv.m`. For documentation,
% see those files.
  degs = opt.degs;
  fid = fopen(fname, 'w');
  fwrite(fid, sprintf('// Code generated by `%s'' for %s window\n', genname, opt.window));
  fwrite(fid, sprintf('// See documentation in the above file.\n'));
  for i=1:numel(degs)
    z = get_sample_points(degs(i)); % compute Chebyshev points
    Vmat = get_interpolation_matrix(degs(i), z); % compute Vandermonde matrix
    Pvec = opt.Ps{i};
    if i == 1
      fwrite(fid, sprintf('if (degree == %d) {\n', degs(i)));
    else
      fwrite(fid, sprintf('} else if (degree == %d) {\n', degs(i)));
    end
    for j=1:numel(Pvec)
      beta = 2.5 * Pvec(j); % relation between beta and P
      % Compute polynomial coefficients
      coeffs = compute_coefficients(z, Vmat, Pvec(j), @(x)Kfun(x,beta));
      if j == 1
        fwrite(fid, sprintf('  if (P == %d) {\n', Pvec(j)));
      else
        fwrite(fid, sprintf('  } else if (P == %d) {\n', Pvec(j)));
      end
      str = output_eval_code(coeffs, opt); % generate code for evaluation
      for i=1:numel(str)
        fwrite(fid, ['    ', str{i}]);
      end
    end
    fwrite(fid, sprintf('  } else {\n    printf("WARNING: width not implemented\\n");\n  }\n'));
  end
  fwrite(fid, sprintf('} else {\n  printf("WARNING: degree not implemented\\n");\n}\n'));
  fclose(fid);
end

% ------------------------------------------------------------------------------
function x = get_sample_points(deg)
  n = deg+1;
  x = cos(pi*((1:n)-0.5)/n)'; % roots of Chebyshev polynomial T_n
end

% ------------------------------------------------------------------------------
function V = get_interpolation_matrix(deg, x)
  x = x(:);
  n = deg+1;
  V = ones(numel(x), n);
  for j=2:n
    V(:,j) = V(:,j-1) .* x;
  end
end

% ------------------------------------------------------------------------------
function coeffs = compute_coefficients(z, Vmat, P, Kfun);
  h = 2/P;
  zsc = 0.5*h*z;
  bin_centers = fliplr(h*((1:P)-0.5) - 1); % flip for consistency with SE
  Kz = zeros(numel(z), 1);
  for j=1:P
    Kz(:,j) = Kfun(zsc + bin_centers(j));
  end
  coeffs = Vmat \ Kz;
end

% ------------------------------------------------------------------------------
function str = output_eval_code(coeffs, opt)
  [ncoeff, P] = size(coeffs);
  str = cell(ncoeff+1, 1);
  % Determine width
  if isfield(opt, 'Ppad') && opt.Ppad
    width = 4*ceil(P/4);
    coeffs = [coeffs, zeros(ncoeff, width-P)];
  else
    width = P;
  end
  % Output coefficients
  for j=1:ncoeff
    s = sprintf('double c%d[] = {%.16E', j-1, coeffs(j,1));
    for i=2:width
      s = sprintf('%s, %.16E', s, coeffs(j,i));
    end
    str{j} = sprintf('%s};\n', s);
  end
  % Output Horner evaluation formula
  s = sprintf('for (int i=0; i<%d; i++) out[i] = ', width);
  for j=1:ncoeff-1
    s = sprintf('%sc%d[i] + z*(', s, j-1); % (j-1)th coeff for ith bin
  end
  s = sprintf('%sc%d[i]', s, ncoeff-1); % last coeff for ith bin
  s = [s, repmat(')', 1, ncoeff-1)]; % close all parentheses
  str{ncoeff+1} = sprintf('%s;\n', s);
end
