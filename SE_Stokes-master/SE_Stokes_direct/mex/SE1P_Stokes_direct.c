#include "SE_Stokes_direct.h"
#include <math.h>

#ifdef HASIMOTO
#include "hasimoto_decomp.h"
#elif BEENAKKER
#error "Beenakker k-space sum not implemented for 1P!"
#else
#error "Must provide -D<decomposition> to compiler"
#endif

#define __EXP_ARG_MAX 600

void hasimoto_op_A(double A[3][3], double x[3], double xi)
{
    double r2 = x[0]*x[0] + x[1]*x[1] + x[2]*x[2];
    double r = sqrt(r2);
    double b = xi*xi*r2;
    double c1 = 2*(xi*exp(-b)/(sqrt(PI)*r2) + erfc(xi*r)/(2*r*r2) );
    double c2 = r2*c1 - 4*xi*exp(-b)/sqrt(PI);
    int i, j;
    for(i=0; i<3; i++)
	for(j=0; j<3; j++)
	    A[i][j] = c1*x[i]*x[j] + c2*(i==j);
}

void SE1P_Stokes_direct_real(double* restrict u, 
			     const int* restrict idx, int nidx,
			     const double* restrict x, 
			     const double* restrict f, int N,
			     const ewald_opts opt)
{
#ifdef _OPENMP
#pragma omp parallel for
#endif
    for(int m=0; m<nidx; m++)
    {
        double rvec[3];
        double r[3];
        double A[3][3];
	u[m       ] =0;
	u[m+nidx  ] =0;
	u[m+2*nidx] =0;
	for(int n=0; n<N; n++)
	{
	    rvec[0] = x[idx[m]    ]-x[n    ];
	    rvec[1] = x[idx[m]+N  ]-x[n+N  ];
	    rvec[2] = x[idx[m]+2*N]-x[n+2*N];

	    for(int p0 = -opt.layers; p0<=opt.layers; p0++)
		{
		    if(idx[m] == n && p0 == 0)
			continue;
			
		    r[0] = rvec[0]+p0*opt.box[0];
		    r[1] = rvec[1];
		    r[2] = rvec[2];
		    
		    hasimoto_op_A(A,r,opt.xi);                      // u += A*f

		    u[m       ] += 
			A[0][0]*f[n    ]+
			A[0][1]*f[n+  N]+
			A[0][2]*f[n+2*N];
		    u[m+nidx  ] += 
			A[1][0]*f[n    ]+
			A[1][1]*f[n+  N]+
			A[1][2]*f[n+2*N];
		    u[m+2*nidx] += 
			A[2][0]*f[n    ]+
			A[2][1]*f[n+  N]+
			A[2][2]*f[n+2*N];	
		}
	}
    }
}

void SE1P_Stokes_direct_real_rc(double* restrict u, 
				const int* restrict idx, int nidx,
				const double* restrict x, 
				const double* restrict f, int N,
				const ewald_opts opt)
{
#ifdef _OPENMP
#pragma omp parallel for
#endif
    for(int m=0; m<nidx; m++)
    {
        double rvec[3];
        double r[3];
        double A[3][3];
	u[m       ] =0;
	u[m+nidx  ] =0;
	u[m+2*nidx] =0;
	for(int n=0; n<N; n++)
	{
	    rvec[0] = x[idx[m]    ]-x[n    ];
	    rvec[1] = x[idx[m]+N  ]-x[n+N  ];
	    rvec[2] = x[idx[m]+2*N]-x[n+2*N];

	    for(int p0 = -opt.layers; p0<=opt.layers; p0++)
		{
		    if(idx[m] == n && p0 == 0)
			continue;
			
		    r[0] = rvec[0]+p0*opt.box[0];
		    r[1] = rvec[1];
		    r[2] = rvec[2];

		    if(sqrt(r[0]*r[0] + r[1]*r[1] + r[2]*r[2]) > opt.rc)
			continue;
		    
		    hasimoto_op_A(A,r,opt.xi);                      // u += A*f

		    u[m       ] += 
			A[0][0]*f[n    ]+
			A[0][1]*f[n+  N]+
			A[0][2]*f[n+2*N];
		    u[m+nidx  ] += 
			A[1][0]*f[n    ]+
			A[1][1]*f[n+  N]+
			A[1][2]*f[n+2*N];
		    u[m+2*nidx] += 
			A[2][0]*f[n    ]+
			A[2][1]*f[n+  N]+
			A[2][2]*f[n+2*N];	
		}
	}
    }
}

// BELOW HERE NOT CHANGED FROM 2P
static inline double theta_plus(double z, double k, double xi)
{
    /* idea for a more stable form [LK] */
    /* exp( k*z + log( erfc(k/(2.0*xi) + xi*z) ) ); */

    if(k*z <  __EXP_ARG_MAX)
	return exp( k*z)*erfc(k/(2.0*xi) + xi*z);
    else 
	return 0.0;
}

static inline double theta_minus(double z, double k, double xi)
{
    /* exp(-k*z + log( erfc(k/(2.0*xi) - xi*z) ) ); */

    if(-k*z <  __EXP_ARG_MAX)
	return exp(-k*z)*erfc(k/(2.0*xi) - xi*z);
    else 
	return 0.0;
}

void SE1P_Stokes_direct_fd(double* restrict u, 
			   const int* restrict idx, int nidx,
			   const double* restrict x, 
			   const double* restrict f, int N,
			   const ewald_opts opt)
{
    double xm[3]; 
    double k_dot_r, z;
    double C = 4/(opt.box[0]*opt.box[1]);
    double f0, f1, f2;
    double k0, k1, nk;
    double Qf_re[3];
    double Qf_im[3];
    double p[3];
    double xi=opt.xi;
    double ce, cp, cm;

    for(int m=0; m<nidx; m++)
    {
	xm[0] = x[idx[m]    ];
	xm[1] = x[idx[m]+N  ];
	xm[2] = x[idx[m]+2*N];

	p[0]=0; 
	p[1]=0; 
	p[2]=0;

	for(int n = 0; n<N; n++)
	{
	    f0=f[n    ];
	    f1=f[n+  N];
	    f2=f[n+2*N];
	    for(int j0 = -opt.layers; j0<=opt.layers; j0++)
		for(int j1 = -opt.layers; j1<=opt.layers; j1++)
		{
		    if(j0 == 0 && j1 == 0)
			continue;

		    k0 = 2*PI*j0/opt.box[0];
		    k1 = 2*PI*j1/opt.box[1];
		    nk = sqrt(k0*k0 + k1*k1);
		    k_dot_r = k0*(xm[0]-x[n]) + k1*(xm[1]-x[n+N]);

		    z = xm[2]-x[n+2*N];

		    ce = exp(-(nk*nk)/(4.0*(xi*xi) ) - (xi*xi)*(z*z) );
		    cp = theta_plus(z,nk,xi);
		    cm = theta_minus(z,nk,xi);

		    /* Real part of Q*f -- code generated by Mathematica 8 */
		    Qf_re[0] = -(f1*k0*k1*sqrt(PI)*(2*ce*nk + sqrt(PI)*xi*(cm + cp + cm*nk*z - cp*nk*z)))/(4.*pow(nk,3)*xi) + (f0*sqrt(PI)*(2*pow(nk,2)*(ce*nk + (cm + cp)*sqrt(PI)*xi) - pow(k0,2)*(2*ce*nk + sqrt(PI)*xi*(cm + cp + cm*nk*z - cp*nk*z))))/(4.*pow(nk,3)*xi);		    
		    Qf_re[1] = -(f0*k0*k1*sqrt(PI)*(2*ce*nk + sqrt(PI)*xi*(cm + cp + cm*nk*z - cp*nk*z)))/(4.*pow(nk,3)*xi) + (f1*sqrt(PI)*(2*pow(nk,2)*(ce*nk + (cm + cp)*sqrt(PI)*xi) - pow(k1,2)*(2*ce*nk + sqrt(PI)*xi*(cm + cp + cm*nk*z - cp*nk*z))))/(4.*pow(nk,3)*xi);
		    Qf_re[2] = (f2*(2*ce*nk*sqrt(PI) + PI*xi*(cm + cp + cm*nk*z - cp*nk*z)))/(4.*nk*xi);

		    /* Imag part of Q*f -- code generated by Mathematica 8 */
		    Qf_im[0] = -((cm + cp)*f2*k0*PI*z)/(4.*nk);
		    Qf_im[1] = -((cm + cp)*f2*k1*PI*z)/(4.*nk);
		    Qf_im[2] = -((cm + cp)*f0*k0*PI*z)/(4.*nk) - ((cm + cp)*f1*k1*PI*z)/(4.*nk);

		    /* 
		       Sum contributions -- 
		       imag part enters with negative sign (from i*i)
		    */
		    p[0] += cos(k_dot_r)*Qf_re[0] - sin(k_dot_r)*Qf_im[0];
		    p[1] += cos(k_dot_r)*Qf_re[1] - sin(k_dot_r)*Qf_im[1];
		    p[2] += cos(k_dot_r)*Qf_re[2] - sin(k_dot_r)*Qf_im[2];
		}
	}

	u[m       ] = C*p[0];
	u[m+nidx  ] = C*p[1];
	u[m+2*nidx] = C*p[2];
    }
}

void SE1P_Stokes_direct_k0(double* restrict u, 
			   const int* restrict idx, int nidx,
			   const double* restrict x, 
			   const double* restrict f, int N,
			   const ewald_opts opt)
{
    double z, zm, p[2],q;
    double C = -4*sqrt(PI)/(opt.box[0]*opt.box[1]);
    for(int m=0; m<nidx; m++)
    {
	p[0] = 0; p[1] = 0; 
	zm = x[idx[m]+2*N];
	for(int n=0; n<N; n++)
	{
	    z = zm - x[n+2*N];
	    q = exp(-opt.xi*opt.xi*z*z)/(2*opt.xi) + sqrt(PI)*z*erf(opt.xi*z);
	    p[0] += q*f[n  ];
	    p[1] += q*f[n+N];
	}
	u[m     ] = C*p[0];
	u[m+nidx] = C*p[1];
    }
}

void SE1P_Stokes_direct_self(double* restrict u, 
			     const int* restrict idx, int nidx,
			     const double* restrict f, int N, 
			     const ewald_opts opt)
{
    double c = -4*opt.xi/sqrt(PI);
    for(int m=0; m<nidx; m++)
    {
	u[m       ] = c*f[idx[m]    ];
	u[m+  nidx] = c*f[idx[m]+N  ];
	u[m+2*nidx] = c*f[idx[m]+2*N];
    }
}

inline double dot(double * a,double * b)
{
  return ( a[0]*b[0] + a[1]*b[1] + a[2]*b[2] );
}

void SE1P_Stokes_direct(double* restrict u, 
				const int* restrict idx, int nidx,
				const double* restrict x, 
				const double* restrict f, int N,
				const ewald_opts opt)
{
#ifdef _OPENMP
#pragma omp parallel for
#endif
    for(int m=0; m<nidx; m++)
    {
        double rvec[3];
        double r[3];
	double p[] = {0,0,0};
	for(int n = 0; n<N; n++)
        {
                double fn[] = {f[n], f[n+N], f[n+2*N]};
                rvec[0] = x[idx[m]    ]-x[n    ];
	        rvec[1] = x[idx[m]+N  ]-x[n+N  ];
	        rvec[2] = x[idx[m]+2*N]-x[n+2*N];
                for(int p0 = -opt.layers; p0<=opt.layers; p0++)
                {
                        r[0] = rvec[0]+p0*opt.box[0];
		        r[1] = rvec[1];
		        r[2] = rvec[2];
	          
	          double rdotf = dot(r,fn);
	          double ri = 1.0/sqrt(dot(r,r));
	          double ri3 = ri*ri*ri;

	          if(idx[m]==n && p0 == 0)
	            continue;
	          p[0] += ri*fn[0] + rdotf*ri3*r[0];
	          p[1] += ri*fn[1] + rdotf*ri3*r[1];
	          p[2] += ri*fn[2] + rdotf*ri3*r[2];
	        }
	        u[m    ] = p[0];
	        u[m+  nidx] = p[1];
	        u[m+2*nidx] = p[2];
              }
        }
}
